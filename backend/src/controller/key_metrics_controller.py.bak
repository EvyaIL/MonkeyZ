from datetime import datetime, timedelta
from typing import List, Dict, Any
import time
from collections import defaultdict
from concurrent.futures import ThreadPoolExecutor
from functools import partial
from src.controller.key_controller import KeyController
from src.models.key.key import KeyStatus

class KeyMetricsController:
    """Controller for key metrics operations."""
    
    def __init__(self, admin_product_collection, keys_collection):
        self.admin_product_collection = admin_product_collection
        self.keys_collection = keys_collection
        self._metrics_cache = {}
        self._cache_time = None
        self._cache_ttl = 300  # 5 minutes cache TTL
        
    async def _should_use_cache(self) -> bool:
        """Check if we should use cached metrics."""
        if not self._cache_time or not self._metrics_cache:
            return False
        age = (datetime.now() - self._cache_time).total_seconds()
        return age < self._cache_ttl
        
    def _update_cache(self, metrics: Dict[str, Any]) -> None:
        """Update the metrics cache."""
        self._metrics_cache = metrics
        self._cache_time = datetime.now()
        
    async def get_key_metrics(self):
        """
        Get metrics about key usage and availability.
        
        Returns:
            dict: Key metrics including total, available, used keys, and product-specific metrics
        """
        # Check cache first
        if await self._should_use_cache():
            return self._metrics_cache
        
        # Initialize metrics
        total_keys = 0
        available_keys = 0
        used_keys = 0
        expired_keys = 0
        low_stock_products = 0
        key_usage_by_product = []
        
        try:
            # Ensure collections are initialized
            try:
                # Use explicit await to ensure initialization completes
                if hasattr(self.admin_product_collection, "initialize"):
                    await self.admin_product_collection.initialize()
                elif hasattr(self.admin_product_collection, "init"):
                    await self.admin_product_collection.init()
            except Exception as e:
                print(f"Failed to initialize admin_product_collection: {e}")
                
            try:
                # Use explicit await to ensure initialization completes
                if hasattr(self.keys_collection, "initialize"):
                    await self.keys_collection.initialize()
                elif hasattr(self.keys_collection, "init"):
                    await self.keys_collection.init()
            except Exception as e:
                print(f"Failed to initialize keys_collection: {e}")
            
            # Get all products with key management settings in a single query
            products = await self.admin_product_collection.get_all_products()
            
            # Debug - show number of products found
            print(f"Found {len(products)} products")
            
            # Initialize a user collection for the key controller
            from src.mongodb.users_collection import UserCollection
            user_collection = UserCollection()
            await user_collection.initialize()
            
            # Create KeyController instance for optimized key fetching
            key_controller = KeyController(self.admin_product_collection, self.keys_collection, user_collection)
            await key_controller.initialize()

            # Initialize metrics tracking
            keys_by_product = defaultdict(list)
            product_processing_count = 0
            last_log_time = time.time()
            batch_size = 1000

            try:                # Get all keys using the optimized batch processing
                batch_count = 0
                async for key in self.keys_collection.get_all_keys(batch_size):
                    try:                # Handle all possible attribute names for product_id
                        product_id = None
                        if hasattr(key, 'product'):
                            product_id = str(key.product)
                        elif hasattr(key, 'productId'):
                            product_id = str(key.productId)
                        elif hasattr(key, 'product_id'):
                            product_id = str(key.product_id)

                        # Try dictionary access for flexibility
                        if not product_id and hasattr(key, 'get'):
                            product_id = str(key.get('product_id') or key.get('productId') or key.get('product') or '')

                        if not product_id:
                            print(f"Warning: Key without product_id found. Key attributes: {dir(key)}")
                            continue

                        keys_by_product[product_id].append(key)
                        
                        # Log progress for long-running operations
                        product_processing_count += 1
                        batch_count += 1
                        
                        if batch_count >= batch_size:
                            current_time = time.time()
                            if current_time - last_log_time >= 5:  # Log every 5 seconds
                                print(f"Processed {product_processing_count} keys...")
                                last_log_time = current_time
                            batch_count = 0
                              except Exception as e:
                        print(f"Error processing key: {e}")
                        continue
            finally:
                # Always clean up controller resources
                await key_controller.disconnect()
                
            # Process products with their pre-grouped keys
            for product in products:
                # Handle Product object or dict
                if hasattr(product, 'id') and callable(getattr(product, 'id', None)):
                    product_id = str(product.id)
                elif hasattr(product, '_id'):
                    product_id = str(product._id)
                else:
                    product_id = str(product.get('_id') or product.get('id'))
                
                # Get product name
                if hasattr(product, 'name') and not isinstance(getattr(product, 'name'), dict):
                    product_name = product.name
                elif hasattr(product, 'name') and isinstance(getattr(product, 'name'), dict):
                    name_dict = product.name
                    product_name = name_dict.get('en') or next(iter(name_dict.values()), "Unknown Product")
                else:
                    name_value = product.get('name', 'Unknown Product')
                    if isinstance(name_value, dict):
                        product_name = name_value.get('en') or next(iter(name_value.values()), "Unknown Product")
                    else:
                        product_name = str(name_value)
                
                print(f"Processing product: {product_id} - {product_name}")
                
                # Get pre-grouped keys for this product
                product_keys = keys_by_product.get(product_id, [])
                
                # Also get cdKeys directly from the product if they exist
                cd_keys = []
                
                # Check if product has cdKeys attribute (handle both object and dict)
                if hasattr(product, 'cdKeys'):
                    cd_keys = product.cdKeys or []
                elif isinstance(product, dict) and 'cdKeys' in product:
                    cd_keys = product['cdKeys'] or []
                
                if cd_keys:
                    print(f"Found {len(cd_keys)} cdKeys directly in product {product_id}")
                    
                    # Add these cdKeys to the product_keys for counting
                    for cd_key in cd_keys:
                        # First check if it's a Pydantic model or dict
                        if hasattr(cd_key, 'dict'):
                            # It's likely a Pydantic model
                            try:
                                is_used = cd_key.isUsed
                            except:
                                is_used = False
                        else:                            # Treat as a dict
                            is_used = cd_key.get('isUsed', False) if isinstance(cd_key, dict) else False
                        
                        # Convert to a key-like object with properties we check elsewhere
                        key_obj = type('CDKeyWrapper', (), {
                            'status': 'used' if is_used else 'available',
                            'isUsed': is_used,
                        })
                        product_keys.append(key_obj)
                
                # Count different key states
                product_total_keys = len(product_keys)
                
                # Log the keys for debugging
                print(f"Product {product_id} ({product_name}) has {product_total_keys} keys")
                
                # Show cdKeys directly from product object
                if hasattr(product, 'cdKeys') and product.cdKeys:
                    print(f"Product has {len(product.cdKeys)} cdKeys in the cdKeys field")
                    
                # Sample key inspection
                if product_keys and len(product_keys) > 0:
                    sample_key = product_keys[0]
                    print(f"Sample key attributes: {dir(sample_key)}")
                    print(f"Sample key status: {getattr(sample_key, 'status', 'Not found')}")
                    print(f"Sample key isUsed: {getattr(sample_key, 'isUsed', 'Not found')}")
                    if hasattr(sample_key, 'dict'):
                        print(f"Sample key as dict: {sample_key.dict()}")
                
                # Count available keys with detailed logging
                available_count = 0
                for key in product_keys:
                    is_available = False
                    # Check status attribute
                    if hasattr(key, 'status'):
                        status_value = getattr(key, 'status')
                        if str(status_value).lower() == 'available' or status_value == KeyStatus.AVAILABLE:
                            is_available = True
                            print(f"Found available key by status: {status_value}")
                    
                    # Check isUsed attribute
                    elif hasattr(key, 'isUsed'):
                        is_used = getattr(key, 'isUsed')
                        if not is_used:
                            is_available = True
                            print(f"Found available key by isUsed=False")
                    
                    if is_available:
                        available_count += 1
                
                product_available_keys = available_count
                print(f"Found {product_available_keys} available keys for product {product_id}")
                
                # Count used keys with detailed logging
                used_count = 0
                for key in product_keys:
                    is_used = False
                    # Check status attribute
                    if hasattr(key, 'status'):
                        status_value = getattr(key, 'status')
                        if str(status_value).lower() == 'used' or status_value == KeyStatus.USED:
                            is_used = True
                            print(f"Found used key by status: {status_value}")
                    
                    # Check isUsed attribute
                    elif hasattr(key, 'isUsed'):
                        is_used_value = getattr(key, 'isUsed')
                        if is_used_value:
                            is_used = True
                            print(f"Found used key by isUsed=True")
                    
                    if is_used:
                        used_count += 1
                
                product_used_keys = used_count
                print(f"Found {product_used_keys} used keys for product {product_id}")
                
                # Check for EXPIRED status (case-insensitive)
                product_expired_keys = sum(1 for key in product_keys 
                    if str(getattr(key, 'status', '')).lower() == 'expired')
                  # Update overall counts
                total_keys += product_total_keys
                available_keys += product_available_keys
                used_keys += product_used_keys
                expired_keys += product_expired_keys
                
                # Check if product is low on stock
                min_stock_threshold = product.get('minStockAlert', 10)
                if product_available_keys <= min_stock_threshold:
                    low_stock_products += 1
                
                # Add product-specific metrics
                key_usage_by_product.append({
                    'productId': product_id,
                    'productName': product_name,
                    'totalKeys': product_total_keys,
                    'availableKeys': product_available_keys,
                    'usedKeys': product_used_keys
                })
          except Exception as e:
            import traceback
            print(f"Error calculating key metrics: {str(e)}")
            print(f"Stack trace: {traceback.format_exc()}")
            
            # Return default values with error info in case of error
            return {
                'totalKeys': 0,
                'availableKeys': 0,
                'usedKeys': 0,
                'expiredKeys': 0,
                'lowStockProducts': 0,
                'keyUsageByProduct': [],
                'error': str(e)
            }
            
        # Calculate average usage time more efficiently using the already processed keys
        average_key_usage_time = None
        try:
            usage_times = []
            # Use already processed keys from keys_by_product
            for product_keys in keys_by_product.values():
                for key in product_keys:
                    if key.get('status') == 'used' and key.get('issuedAt') and key.get('usedAt'):
                        issued_at = key.get('issuedAt')
                        used_at = key.get('usedAt')
                        if issued_at and used_at:
                            # Calculate time difference in hours
                            time_diff = (used_at - issued_at).total_seconds() / 3600
                            usage_times.append(time_diff)
                
                if usage_times:
                    average_key_usage_time = sum(usage_times) / len(usage_times)
        except Exception as e:
            print(f"Error calculating average key usage time: {str(e)}")
        
        # Update cache with the new metrics
        self._update_cache({
            'totalKeys': total_keys,
            'availableKeys': available_keys,
            'usedKeys': used_keys,
            'expiredKeys': expired_keys,
            'lowStockProducts': low_stock_products,
            'averageKeyUsageTime': average_key_usage_time,
            'keyUsageByProduct': key_usage_by_product
        })
        
        return {
            'totalKeys': total_keys,
            'availableKeys': available_keys,
            'usedKeys': used_keys,
            'expiredKeys': expired_keys,
            'lowStockProducts': low_stock_products,
            'averageKeyUsageTime': average_key_usage_time,
            'keyUsageByProduct': key_usage_by_product
        }
